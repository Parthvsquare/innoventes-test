// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: Music.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addNewMusic = `-- name: AddNewMusic :one
INSERT INTO Music (music_name, music_price, music_description, album_id, musician_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING music_id, music_name, music_price, music_description, album_id, musician_id
`

type AddNewMusicParams struct {
	MusicName        string         `json:"music_name"`
	MusicPrice       pgtype.Numeric `json:"music_price"`
	MusicDescription pgtype.Text    `json:"music_description"`
	AlbumID          pgtype.UUID    `json:"album_id"`
	MusicianID       pgtype.UUID    `json:"musician_id"`
}

func (q *Queries) AddNewMusic(ctx context.Context, arg AddNewMusicParams) (Music, error) {
	row := q.db.QueryRow(ctx, addNewMusic,
		arg.MusicName,
		arg.MusicPrice,
		arg.MusicDescription,
		arg.AlbumID,
		arg.MusicianID,
	)
	var i Music
	err := row.Scan(
		&i.MusicID,
		&i.MusicName,
		&i.MusicPrice,
		&i.MusicDescription,
		&i.AlbumID,
		&i.MusicianID,
	)
	return i, err
}

const deleteMusic = `-- name: DeleteMusic :exec
DELETE FROM Music WHERE music_id = $1
`

func (q *Queries) DeleteMusic(ctx context.Context, musicID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMusic, musicID)
	return err
}

const getMusicByAlbumId = `-- name: GetMusicByAlbumId :many
SELECT music_id, music_name, music_price, music_description, album_id, album_name, release_date, genre, price, description, musician_id, musician_name, musician_type FROM album_music_musician_view WHERE album_id = $1
`

func (q *Queries) GetMusicByAlbumId(ctx context.Context, albumID uuid.UUID) ([]AlbumMusicMusicianView, error) {
	rows, err := q.db.Query(ctx, getMusicByAlbumId, albumID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AlbumMusicMusicianView{}
	for rows.Next() {
		var i AlbumMusicMusicianView
		if err := rows.Scan(
			&i.MusicID,
			&i.MusicName,
			&i.MusicPrice,
			&i.MusicDescription,
			&i.AlbumID,
			&i.AlbumName,
			&i.ReleaseDate,
			&i.Genre,
			&i.Price,
			&i.Description,
			&i.MusicianID,
			&i.MusicianName,
			&i.MusicianType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMusicById = `-- name: GetMusicById :one
SELECT music_id, music_name, music_price, music_description, album_id, musician_id FROM Music WHERE music_id = $1
`

func (q *Queries) GetMusicById(ctx context.Context, musicID uuid.UUID) (Music, error) {
	row := q.db.QueryRow(ctx, getMusicById, musicID)
	var i Music
	err := row.Scan(
		&i.MusicID,
		&i.MusicName,
		&i.MusicPrice,
		&i.MusicDescription,
		&i.AlbumID,
		&i.MusicianID,
	)
	return i, err
}

const updateMusic = `-- name: UpdateMusic :one
UPDATE Music
SET
    music_name = COALESCE($1, music_name),
    music_price = COALESCE($2, music_price),
    music_description = COALESCE($3, music_description),
    album_id = COALESCE($4, album_id),
    musician_id = COALESCE($5, musician_id)
WHERE music_id = $6
RETURNING music_id, music_name, music_price, music_description, album_id, musician_id
`

type UpdateMusicParams struct {
	MusicName        string         `json:"music_name"`
	MusicPrice       pgtype.Numeric `json:"music_price"`
	MusicDescription pgtype.Text    `json:"music_description"`
	AlbumID          pgtype.UUID    `json:"album_id"`
	MusicianID       pgtype.UUID    `json:"musician_id"`
	MusicID          uuid.UUID      `json:"music_id"`
}

func (q *Queries) UpdateMusic(ctx context.Context, arg UpdateMusicParams) (Music, error) {
	row := q.db.QueryRow(ctx, updateMusic,
		arg.MusicName,
		arg.MusicPrice,
		arg.MusicDescription,
		arg.AlbumID,
		arg.MusicianID,
		arg.MusicID,
	)
	var i Music
	err := row.Scan(
		&i.MusicID,
		&i.MusicName,
		&i.MusicPrice,
		&i.MusicDescription,
		&i.AlbumID,
		&i.MusicianID,
	)
	return i, err
}
